<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="pt" xml:lang="pt" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Concept: Testes de Desenvolvedor</title>
<meta name="uma.type" content="Concept">
<meta name="uma.name" content="testes_de_desenvolvedor">
<meta name="uma.presentationName" content="Testes de Desenvolvedor">
<meta name="element_type" content="concept">
<meta name="filetype" content="description">
<meta name="role" content="none">
<link rel="StyleSheet" href="./../../../css/default.css" type="text/css">
<script src="./../../../scripts/ContentPageResource.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSubSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageToolbar.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/contentPage.js" type="text/javascript" language="JavaScript"></script><script type="text/javascript" language="JavaScript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="4.085829182735815E-305"></div>
<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="pageTitle" nowrap="true">Concept: Testes de Desenvolvedor</td><td width="100%">
<div align="right" id="contentPageToolbar"></div>
</td><td width="100%" class="expandCollapseLink" align="right"><a name="mainIndex" href="./../../../index.htm"></a><script language="JavaScript" type="text/javascript" src="./../../../scripts/treebrowser.js"></script></td>
</tr>
</table>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td class="pageTitleSeparator"><img src="./../../../images/shim.gif" alt="" title="" height="1"></td>
</tr>
</table>
<div class="overview">
<table width="97%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="50"><img src="./../../../images/concept.gif" alt="" title=""></td><td>
<table class="overviewTable" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Relationships</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<th class="sectionTableHeading" scope="row">Related Elements</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../xp/roles/programador_xp_D005E927.html" guid="{08A6AF28-69B1-42DC-A957-2E6CDCB436C1}">Programador XP</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Main Description</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="XE_test__developer_testing__concept_of" name="XE_test__developer_testing__concept_of"></a><a id="XE_design__developer_testing__concept_of" name="XE_design__developer_testing__concept_of"></a> 
<h3>
    <a id="Introduction" name="Introduction"></a>Introdução
</h3>
<p>
    O termo "Teste de Desenvolvedor" é usado para classificar as atividades de testes mais apropriadamente realizadas por
    desenvolvedores de software. Isto também Inclui os artefatos criados por essas atividades. Os Testes de Desenvolvedor
    englobam o trabalho tradicionalmente elaborado nas seguintes categorias: Teste de Unidade, grande parte dos Testes de
    Integração e alguns aspectos do que é normalmente chamado de Testes de Sistema. Apesar dos Testes de Desenvolvedor
    estarem tradicionalmente associados com as atividades da disciplina de Implementação, eles também têm uma relação com
    as atividades da disciplina de Análise e Design.
</p>
<p>
    Pensando nos Testes de Desenvolvedor desta forma "holística", você ajudará a atenuar alguns dos riscos associados com
    as abordagens mais "atomizadas", tradicionalmente usadas. Na abordagem tradicional para Testes de Desenvolvedor, o
    esforço é inicialmente focado na avaliação de que todas as unidades estejam trabalhando de forma independente.
    Posteriormente no ciclo de vida de desenvolvimento, à medida que o trabalho de desenvolvimento se aproxima da
    conclusão, as unidades integradas são agrupadas em um sistema ou subsistema executável e testadas desta forma, pela
    primeira vez.
</p>
<p>
    Esta abordagem tem uma série de falhas. Em primeiro lugar, porque encoraja uma abordagem em fases para os testes das
    unidades integradas e posteriormente os subsistemas, todos os erros identificados durante estes testes são normalmente
    encontrados tarde demais. Esta descoberta tardia normalmente resulta na decisão de não tomar nenhuma ação corretiva, ou
    na exigência de grande retrabalho para correção. Este retrabalho tanto é caro como susceptível de atrasar o progresso
    em outras áreas. Isso aumenta o risco do projeto ser desviado ou abandonado.
</p>
<p>
    Em segundo lugar, quando criamos limites rígidos entre os Testes Unitários, de Integração e de Sistema, aumentamos a
    probabilidade de que os erros que estejam no perímetro destes limites não sejam descobertos por ninguém. O risco é
    agravado quando a responsabilidade por esses tipos de testes é atribuída a equipes diferentes.
</p>
<p>
    O estilo dos testes de desenvolvedor recomendado pelos processos iterativos, encoraja o desenvolvedor a se concentrar
    nos testes mais valiosos e adequados a serem conduzidos em determinado momento. Mesmo no escopo de uma única iteração,
    geralmente é mais eficiente para o desenvolvedor localizar e corrigir a maioria dos erros no seu próprio código,
    evitando a sobrecarga adicional de passar para outro grupo de testes. O resultado desejado é a rápida descoberta dos
    erros de software mais importantes - não importando se estes erros estejam na unidade independente, na integração das
    unidades ou no funcionamento das unidades integradas em um cenário de usuário final.
</p>
<h3>
    <a id="DeveloperTestingPitfalls" name="DeveloperTestingPitfalls"></a>Armadilhas no Início do Uso de Testes de
    Desenvolvedor
</h3>
<p>
    Muitos desenvolvedores, que começam a fazer um trabalho substancialmente mais profundo de teste, desistem do esforço
    rapidamente. Eles acham que os testes não serão produtivos. Além disso, alguns desenvolvedores que começam bem com os
    testes de desenvolvedor, descobrem que criaram uma suíte de teste impossível de manter e que normalmente é abandonada.
</p>
<p>
    Esta página fornece algumas diretrizes para vencer as primeiras barreiras e para a criação de uma suíte de testes que
    evite os problemas de manutenção. Para mais informações, consulte Diretrizes: Mantendo Suítes de Testes Automatizados.
</p>
<h4>
    Estabeleça expectativas
</h4>
<p>
    Aqueles que acham os testes de desenvolvedor gratificantes irão fazê-los. Aqueles que os veem somente como faina
    encontram formas de evitá-los. Trata-se simplesmente na natureza de muitos desenvolvedores na maioria das indústrias, e
    tratar isso como uma falta vergonhosa de disciplina não tem sido historicamente bem sucedido. Portanto, como um
    desenvolvedor você deve esperar que os testes sejam gratificantes e fazer o que for preciso para torná-los
    gratificantes.
</p>
<p>
    Os testes de desenvolvedor ideais seguem um ciclo edição-teste muito curto. Você faz uma pequena alteração no produto,
    tal como adicionar um novo método a uma classe, e então re-executa seus testes imediatamente. Se algum teste não
    passar, você saberá exatamente qual código causou a falha. Este ritmo de desenvolvimento fácil e seguro, é a maior
    recompensa dos testes de desenvolvedor. Uma longa sessão de depuração deverá ser excepcional.
</p>
<p>
    O fato de ser comum que uma mudança feita em uma classe acarrete erro em outra, implica que você terá que re-executar
    não apenas os testes da classe alterada, mas muitos outros. Idealmente, você re-executará a suíte de teste completa
    para seu componente muitas vezes por hora. Toda vez que fizer uma alteração significativa, você re-executará a suíte,
    observará os resultados e avançará para a próxima alteração ou corrigirá a última alteração. Poderá ser necessário
    investir algum esforço para tornar possível esse rápido feedback.
</p>
<h4>
    Automatize seus testes
</h4>
<p>
    Se os testes forem manuais, executá-los várias vezes pode não ser muito prático. Para alguns componentes, os testes
    automatizados são fáceis. Um exemplo seria uma base de dados em memória. Ela se comunica com seus clientes através de
    uma API e não tem nenhuma outra interface com o mundo exterior. Os testes para ela seriam semelhantes a este:
</p>
<p>
    Os testes são diferentes do código cliente normal em um único aspecto: ao invés de confiar nos resultados das chamadas
    a API, eles os verificam. Se a API tornar mais fácil a escrita do código cliente, também tornará mais fácil a escrita
    do código de teste. Se o código de teste <i>não</i> for fácil de escrever, você já terá um alerta de que a API pode ser
    melhorada. O Design Teste-Primeiro é, portanto, coerente com o foco do processo iterativo no cedo tratamento dos riscos
    importantes.
</p>
<p>
    Quão mais estreitamente ligado ao mundo exterior o componente for, mais difícil será de testá-lo. Existem dois casos
    comuns: interfaces gráficas de usuário e componentes de retaguarda.
</p>
<h5>
    Interfaces gráficas de usuário
</h5>
<p>
    Suponha que o banco de dados no exemplo acima receba seus dados através de um retorno de chamada ao objeto de interface
    de usuário. O retorno de chamada é invocado quando o usuário preenche alguns campos de texto e pressiona um botão.
    Testá-lo manualmente preenchendo os campos e pressionando o botão não é algo que você deseje fazer várias vezes
    seguidas. Você tem que arranjar uma forma de efetuar a entrada sob controle programático, normalmente "pressionando" o
    botão via código.
</p>
<p>
    Pressionar o botão irá fazer com que algum código no componente seja executado. É provável, que o código mude o estado
    de alguns objetos da interface de usuário. Sendo assim você também deve arranjar uma maneira de consultar esses objetos
    de forma programática.
</p>
<h5>
    Componentes de retaguarda
</h5>
<p>
    Suponha que o componente em teste não implemente uma base de dados. Ao invés, é uma emulação de uma base de dados em
    disco. O teste em uma base de dados verdadeira poderia ser difícil. Talvez seja difícil de instalar e configurar. As
    licenças para isso podem ser caras. A base de dados poderá tornar os testes lentos o bastante para que você não fique
    inclinado a executá-los com frequência. Nestes casos, vale a pena substituir a base de dados por um simples componente
    que seja suficiente para permitir a execução dos testes.
</p>
<p>
    Essas substituições também são úteis quando o seu componente tem que interagir com outro que ainda não esteja pronto.
    Você não quer que o seu teste fique aguardando pelo código de outra pessoa.
</p>
<p>
    Para mais informações, veja Conceitos: Stubs.
</p>
<h4>
    Não escreva suas próprias ferramentas
</h4>
<p>
    Os testes de desenvolvedor parecem ser bem simples. Você cria alguns objetos, faz uma chamada através de uma API,
    verifica os resultados e anuncia a falha do teste se os resultados não forem os esperados. É também conveniente ter
    alguma forma de agrupar os testes, a fim de que eles possam ser executados individualmente ou como suítes completas. As
    ferramentas que suportam esses requisitos são chamadas de <i>frameworks de teste</i>.
</p>
<p>
    Os testes de desenvolvedor <b>são</b> simples, e os requisitos para os frameworks de teste não são complicados. Se, no
    entanto, você cair na tentação de escrever seu próprio framework de teste, você poderá gastar muito mais tempo com
    ajustes no framework do que provavelmente esperava. Existem muitos frameworks de teste disponíveis, tanto comerciais
    como de código aberto, e não há nenhuma razão para não usar um deles.
</p>
<h4>
    Crie código de suporte
</h4>
<p>
    O código do teste tende a ser repetitivo. É comum ver sequências de código como esta:
</p>
<p>
    Este código é criado copiando uma verificação, colando-a e então a editando para fazer outra verificação.
</p>
<p>
    O perigo aqui é duplo. Se a interface mudar, muita edição terá que ser feita. (Nos casos mais complexos, uma simples
    substituição global, não basta.) Também, se o código for muito complicado, a intenção do teste pode ficar perdida no
    texto.
</p>
<p>
    Quando você notar que está se repetindo, considere seriamente a fatoração das repetições em código de suporte. Embora o
    código acima seja um mero exemplo, ficará mais legível e manutenível se for escrito assim:
</p>
<p>
    Os desenvolvedores escrevem testes muitas vezes errados pelo fato de copiar-e-colar. Se você suspeitar que esteja nesta
    tendência, será mais útil errar conscientemente na outra direção. Limpe seu código de todo texto duplicado.
</p>
<h4>
    Escreva os testes primeiro
</h4>
<p>
    Escreve os testes após o código é uma faina. A urgência é correr com eles, para terminá-los e seguir em frente.
    Escrever os testes antes do código faz parte de um ciclo de feedback positivo. À medida que você implemente mais
    código, você verá mais testes passarem até finalmente todos os testes executarem com sucesso. As pessoas que escrevem
    os testes primeiro aparentam ser mais bem sucedidas, e isso não requer muito tempo. Para obter mais informações, veja
    <a class="elementLinkWithType" href="./../../../xp/guidances/concepts/design_teste-primeiro_73AA5ED9.html" guid="6.556259235358794E-306">Concept: Design Teste-Primeiro</a>.
</p>
<h4>
    Mantenha os testes compreensíveis
</h4>
<p>
    É possível que você, ou alguém, tenha que modificar os testes posteriormente. Uma situação típica é que uma iteração
    posterior exija uma mudança no comportamento de um componente. Por exemplo, suponha que o componente tenha declarado um
    método para raiz quadrada como este:
</p>
<p>
    Nessa versão, um argumento negativo faz com que <font size="+0">sqrt</font> retorne NaN ("não é um número" do <i>Padrão
    para Aritmética Binária de Ponto Flutuante</i> IEEE 754-1985). Na nova iteração, o método para raiz quadrada aceitará
    números negativos e retornará um resultado complexo:
</p>
<p>
    Os testes anteriores para <font size="+0">sqrt</font> terão que ser alterados. O que significa compreender o que eles
    fazem, e atualizá-los para que funcionem com o novo método <font size="+0">sqrt</font>. Ao atualizar os testes, você
    deve tomar cuidado para não destruir o seu poder de encontrar erros. Uma forma que às vezes acontece é a seguinte:
</p>
<p>
    Outras formas são mais sutis: os testes foram alterados para que realmente funcionem, mas eles já não testam o que
    originalmente teriam que testar. O resultado final, após várias iterações, poderá ser uma suíte de teste muito fraca
    que não detecte vários erros. Isto é normalmente chamado de "decadência da suíte de teste". Uma suíte decadente será
    abandonada, porque sua manutenção não é viável.
</p>
<p>
    Você não pode manter um esforço de busca de erros de teste se não estiver claro quais <a class="elementLinkWithUserText" href="./../../../xp/guidances/concepts/lista_de_ideias_de_teste_9B7EE6E1.html#TestIdeas" guid="8.834380241450745E-306">Ideias de Teste</a> um teste implementa. O código de teste tende a ser pouco comentado,
    mesmo que seja difícil de entender o "porque" que está por trás do código do produto.
</p>
<p>
    A decadência de suítes de teste é menos provável nos testes diretos para <font size="+0">sqrt</font> do que nos
    indiretos. Haverá um código que evocará <font size="+0">sqrt</font>. Este código terá testes. Quando <font     size="+0">sqrt</font> for alterada, alguns destes testes irão falhar. A pessoa que alterou <font size="+0">sqrt</font>
    provavelmente terá que alterar esses testes. Pelo fato dela estar menos familiarizada com eles, e do seu relacionamento
    com a mudança ser menos claro, ela estará mais suscetível a enfraquecê-los no processo de fazê-los passar.
</p>
<p>
    Quando você estiver criando código de suporte para os testes (como descrito acima), tenha cuidado: o código de suporte
    deve esclarecer, e não obscurecer, o propósito dos testes que o usam. Uma queixa comum sobre programas orientados a
    objeto é que não existe um único lugar onde tudo seja feito. Se você olhar para qualquer método, tudo o que você
    descobre é que ele transmite o trabalho para outro lugar. Essa estrutura tem vantagens, mas torna mais difícil aos
    novatos a compreensão do código. A menos que eles façam um esforço, suas alterações poderão ser incorretas ou tornar o
    código ainda mais complicado e frágil. O mesmo é válido para código de teste, exceto pelo fato de que será ainda menos
    provável que os mantenedores tomem o devido cuidado mais tarde. Você deve evitar o problema escrevendo testes
    compreensíveis.
</p>
<h4>
    Iguale a estrutura do teste com a do produto
</h4>
<p>
    Suponha que uma pessoa tenha herdado o seu componente. Ela precisa mudar uma parte dele. Ela pode querer examinar os
    testes antigos para ajudá-la em seu novo design. Ela quer atualizar os testes antigos antes de escrever o código
    (design teste-primeiro).
</p>
<p>
    Todas essas boas intenções serão inúteis, se ela não puder encontrar os testes apropriados. Ela fará a alteração,
    verificará as falhas e corrigirá os testes. Isto irá contribuir para a decadência da suíte de teste.
</p>
<p>
    Por essa razão, é importante que a suíte de teste seja bem estruturada, e que a localização dos testes seja previsível
    na estrutura do produto. Geralmente, os desenvolvedores organizam os testes em uma hierarquia paralela, com uma classe
    de teste para cada classe do produto. Portanto, se alguém estiver alterando uma classe chamada <font     size="+0">Registro</font>, ele saberá que a classe de teste se chamará <font size="+0">TestaRegistro</font>, e saberá
    onde o arquivo fonte pode ser encontrado.
</p>
<h4>
    Deixe os testes violarem o encapsulamento
</h4>
<p>
    Você pode limitar seus testes para interagir com o seu componente exatamente como o código cliente faz, através da
    mesma interface que o código cliente usa. Entretanto, isso tem desvantagens. Suponha que você está testando uma classe
    simples que mantém uma lista duplamente encadeada:
</p>
<p align="center">
    <img height="46" alt="" src="./../../../xp/guidances/concepts/resources/dvltst-img1.gif" width="195" />
</p>
<p class="picturetext">
    Fig1: Lista duplamente-encadeada
</p>
<p>
    Em particular, você está testando o método <font size="+0">DoublyLinkedList.insertbefore(Objeto existente, Objeto
    newObject)</font>. Em um de seus testes, você pretende inserir um elemento no meio da lista e verificar se ele foi
    inserido com sucesso. O teste usa a lista acima para criar esta lista atualizada:
</p>
<p align="center">
    <img height="46" alt="" src="./../../../xp/guidances/concepts/resources/dvltst-img2.gif" width="318" />
</p>
<p class="picturetext">
    Fig2: Lista duplamente-encadeada com item inserido
</p>
<p>
    Ele verifica a exatidão da lista assim:
</p>
<p>
    Isto parece ser suficiente, mas não é. Suponha que a implementação da lista esteja incorreta e que os ponteiros de
    retorno não estejam definidos corretamente. Isto é, suponha que a lista atualizada se parece com:
</p>
<p align="center">
    <img height="73" alt="" src="./../../../xp/guidances/concepts/resources/dvltst-img3.gif" width="318" />
</p>
<p class="picturetext">
    Fig3: Lista duplamente-encadeada com falha na implementação
</p>
<p>
    Se <font size="+0">DoublyLinkedList.get(int index)</font> percorrer a lista do início ao fim (provavelmente), o teste
    não perceberá esta falha. Se a classe fornecer os métodos <font size="+0">elementBefore</font> e <font     size="+0">elementAfter</font>, a verificação destas falhas será simples:
</p>
<p>
    Mas e se ela não fornecer esses métodos? Você pode conceber sequências de chamadas de método mais elaboradas que irão
    falhar se o defeito suspeito estiver presente. Por exemplo, isto poderia funcionar:
</p>
<p>
    Mas este teste é mais trabalhoso de criar e provavelmente será significativamente mais difícil de manter. (A menos que
    você escreva bons comentários, não ficará claro porque o teste está fazendo o que faz). Existem duas soluções:
</p>
<ol>
    <li>
        Adicione os métodos <font size="+0">elementBefore</font> e <font size="+0">elementAfter</font> à interface pública.
        Mas que exponha efetivamente a implementação para todos e torne as mudanças futuras mais difíceis.
    </li>
    <li>
        Permita aos testes "olharem sob a capa" e marque ponteiros diretamente.
    </li>
</ol>
<p>
    Esta é geralmente a melhor solução, mesmo que seja para uma simples classe como <font size="+0">DoublyLinkedList</font>
    e especialmente para as classes mais complexas que existem em seus produtos.
</p>
<p>
    Normalmente, os testes são colocados no mesmo pacote onde estão as classes que eles verificam. Eles fornecem acesso
    amigo ou protegido.
</p>
<h3>
    <a id="TestDesignMistakes" name="TestDesignMistakes"></a>Erros Característicos de Design de Teste
</h3>
<p>
    Cada teste exercita um componente e verifica se os resultados estão corretos. O design do teste, as entradas que ele
    usa e como verifica se o resultado está correto, podem ser bons para revelar defeitos, ou podem inadvertidamente
    ocultá-los. Aqui estão algumas características dos erros no design de testes.
</p>
<h4>
    Falha na especificação dos resultados esperados com antecedência
</h4>
<p>
    Suponha que você está testando um componente que converte XML em HTML. É uma tentação pegar algumas amostras de XML,
    executar a conversão e, em seguida, analisar os resultados em um navegador. Se a tela parecer correta, você "abençoa" o
    HTML e o salva como o resultado esperado oficial. Depois, um teste compara os resultados reais da conversão com os
    resultados esperados.
</p>
<p>
    Esta é uma prática perigosa. Mesmo experientes usuários de computador são levados a acreditar no que o computador faz.
    É provável que você ignore erros na apresentação da tela. (Sem mencionar que navegadores são bastante tolerantes a HTML
    malformado). Ao tornar esse HTML incorreto o resultado esperado oficial, você garantirá que o teste nunca poderá
    encontrar o problema.
</p>
<p>
    É menos perigoso executar uma verificação-dupla, olhando diretamente para o HTML, mas isso ainda é perigoso. Por causa
    da saída complicada, será fácil não perceber os erros. Você encontrará mais defeitos se você escrever manualmente a
    saída esperada primeiro.
</p>
<h4>
    Falha na verificação da retaguarda
</h4>
<p>
    Os testes normalmente verificam se aquilo que deveria ter sido mudado foi mudado, mas seus criadores frequentemente se
    esquecem de verificar se aquilo que deveria ter sido deixado de lado foi deixado de lado. Por exemplo, suponha que um
    programa deva alterar os 100 primeiros registros em um arquivo. É uma boa ideia verificar se o 101<sup>o</sup> não foi
    alterado.
</p>
<p>
    Em teoria, você deveria verificar que tudo na "retaguarda"; todo o sistema de arquivos, toda a memória, tudo que for
    acessível pela rede; foi deixado intacto. Na prática, você deve escolher cuidadosamente o que pode verificar. Mas é
    importante fazer essa escolha.
</p>
<h4>
    Falha na verificação da persistência
</h4>
<p>
    Só porque o componente lhe disse que uma mudança foi feita, não significa que tenha sido efetivamente executada na base
    de dados. Você precisa verificar a base de dados através de outro caminho.
</p>
<h4>
    Falha na adição de variedade
</h4>
<p>
    Um teste pode ser projetado para verificar o efeito de três campos em um registro da base de dados, mas muitos outros
    campos devem ser preenchidos para executar o teste. Os Testadores irão normalmente usar os mesmos valores várias vezes
    para estes campos "irrelevantes". Por exemplo, eles sempre usarão o nome da namorada em um campo texto, ou 999 em um
    campo numérico.
</p>
<p>
    O problema é que, o que não importa, às vezes é realmente importante. Quantas vezes existem problemas que dependem de
    alguma combinação obscura de entradas improváveis. Se você usar sempre as mesmas entradas, você não terá nenhuma chance
    de encontrar esses erros. Se você variar as entradas persistentemente, você poderá encontrar os erros. Muitas vezes,
    não custa nada utilizar um número diferente de 999 ou usar o nome de outra pessoa. Quando a variação dos valores
    utilizados em testes não custar nada e algum benefício potencial for gerado, então varie. (Nota: é desaconselhável a
    utilização dos nomes das namoradas antigas se a atual estiver trabalhando com você.)
</p>
<p>
    Aqui está mais um benefício. Uma falha plausível é quando o programa usa o campo <i>X</i> quando deveria ter usado o
    campo <i>Y</i>. Se ambos os campos contiverem "Alvorada", a falha não poderá ser detectada.
</p>
<h4>
    Falha pelo não uso de dados realistas
</h4>
<p>
    É comum a utilização de dados criados para os testes. Normalmente esses dados são simples e irreais. Por exemplo, os
    nomes de clientes podem ser "Mickey", "Snoopy" e "Donald". Pelo fato destes dados serem diferentes do que os usuários
    realmente irão entrar - caracteristicamente curtos - eles poderão esconder defeitos reais que os clientes irão
    descobrir. Por exemplo, esses nomes com somente uma palavra não detectarão que o código não pode tratar nomes com
    espaços.
</p>
<p>
    É prudente fazer um pequeno esforço extra para usar dados realistas.
</p>
<h4>
    Falha em notar que o código simplesmente não faz nada
</h4>
<p>
    Suponha que você inicializou um registro na base de dados com zeros, executou um cálculo que resultará em zero e será
    armazenado no registro e, em seguida, irá verificar se o registro é zero. O que o seu teste demonstrou? O cálculo pode
    simplesmente não ter acontecido. Pode não ter sido armazenado nada, e o teste não irá identificar.
</p>
<p>
    Este exemplo parece pouco provável. Mas esse mesmo erro pode surgir de forma sutil. Por exemplo, você pode escrever um
    teste para um complexo programa de instalação. O teste destina-se a verificar que todos os arquivos temporários serão
    removidos após uma instalação com sucesso. Mas, por causa das opções do instalador, um determinado arquivo temporário
    não foi criado no teste. Certamente, esse é o que o programa se esqueceu de remover.
</p>
<h4>
    Falha em notar que o código faz a coisa errada
</h4>
<p>
    Às vezes um programa faz a coisa certa por razões erradas. Como um exemplo trivial, considere o seguinte código:
</p>
<p>
    A expressão lógica está errada, e você escreveu um teste que o faz avaliar incorretamente e escolher o caminho errado.
    Infelizmente, por pura coincidência, a variável X tem o valor 2, no teste. Sendo assim o resultado do caminho errado
    está acidentalmente correto - o mesmo resultado aconteceria se o caminho correto fosse seguido.
</p>
<p>
    Para cada resultado esperado, você deve perguntar se há uma forma plausível desse resultado ser alcançado pelo motivo
    errado. Mesmo sendo muitas vezes impossível de saber, às vezes não é.
</p></td>
</tr>
</table>
</div>
<table class="copyright" border="0" cellspacing="0" cellpadding="0">
<tr>
<td class="copyright">Copyright (c) 2002, 2006 IBM Corporation e Object Mentor. Todos os Direitos Reservados. <br /> Este programa e o material que o acompanha são disponibilizados sob os termos da Eclipse Public License v1.0, que acompanha esta distribuição e está disponível em <a href="http://www.eclipse.org/legal/epl-v10.html" target="_blank">http://www.eclipse.org/legal/epl-v10.html.</a> <br /> Colaboradores: IBM Corporation e Object Mentor - implementação inicial<br /></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
				contentPage.onload();
			</script>
</html>
