<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="pt" xml:lang="pt" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Guideline: Desenvolvimento Dirigido por Testes (TDD)</title>
<meta name="uma.type" content="Guideline">
<meta name="uma.name" content="desenvolvimento_dirigido_por_testes_tdd">
<meta name="uma.presentationName" content="Desenvolvimento Dirigido por Testes (TDD)">
<meta name="element_type" content="other">
<meta name="filetype" content="description">
<meta name="role" content="none">
<link rel="StyleSheet" href="./../../../css/default.css" type="text/css">
<script src="./../../../scripts/ContentPageResource.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSubSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageToolbar.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/contentPage.js" type="text/javascript" language="JavaScript"></script><script type="text/javascript" language="JavaScript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="3.9254165491375454E-306"></div>
<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="pageTitle" nowrap="true">Guideline: Desenvolvimento Dirigido por Testes (TDD)</td><td width="100%">
<div align="right" id="contentPageToolbar"></div>
</td><td width="100%" class="expandCollapseLink" align="right"><a name="mainIndex" href="./../../../index.htm"></a><script language="JavaScript" type="text/javascript" src="./../../../scripts/treebrowser.js"></script></td>
</tr>
</table>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td class="pageTitleSeparator"><img src="./../../../images/shim.gif" alt="" title="" height="1"></td>
</tr>
</table>
<div class="overview">
<table width="97%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="50"><img src="./../../../images/guidance.gif" alt="" title=""></td><td>
<table class="overviewTable" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Relationships</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<th class="sectionTableHeading" scope="row">Related Elements</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../xp/tasks/escrever_codigo_1F00FE55.html" guid="{8F6CB99A-D2EA-44BB-8CE5-F97220D44088}">Escrever Código</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Main Description</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="XE_xp__test_driven_development" name="XE_xp__test_driven_development"></a><a id="XE_test_driven_development__in_xp" name="XE_test_driven_development__in_xp"></a> 
<h3>
    Tópicos
</h3>
<ul>
    <li>
        <a href="#WhatIs">O que é TDD?</a>
    </li>
    <li>
        <a href="#Java">Um exemplo de TDD em Java</a>
    </li>
    <li>
        <a href="#Benefits">Quais são os benefícios do TDD?</a>
    </li>
    <li>
        <a href="#Costs">Quais são os custos do TDD?</a>
    </li>
    <li>
        <a href="#Principles">Quais princípios de teste eu devo empregar?</a>
    </li>
    <li>
        <a href="#GUIS">Como posso testar GUIs?</a>
    </li>
    <li>
        <a href="#Embedded">Como posso testar sistemas incorporados?</a>
    </li>
    <li>
        <a href="#Concurrency">Como posso testar concorrência?</a>
    </li>
    <li>
        <a href="#Database">Como posso testar transações de banco de dados?</a>
    </li>
    <li>
        <a href="#Servlets">Como posso testar servlets?</a>
    </li>
    <li>
        <a href="#WebPages">Como posso testar páginas Web?</a>
    </li>
</ul>
<h3>
    <a id="WhatIs" name="WhatIs">O que é TDD?</a>
</h3>
<p>
    TDD é a prática de escrever testes de unidade e código de produção concorrentemente e com alto nível de detalhe. Um par
    de programadores escreve primeiro uma pequena parte de um teste de unidade e, em seguida, escrevem código de produção
    suficiente apenas para fazer este teste de unidade compilar e executar. Então eles escrevem um pouco mais do teste e
    acrescentam código de produção suficiente para fazer com que esse novo teste compile e execute com sucesso. Este ciclo
    pode durar de 30 segundos a cinco minutos. Raramente alcança dez minutos. Em cada ciclo, os testes vêm em primeiro
    lugar. Uma vez que um teste de unidade esteja pronto, eles constroem outro até que todos os testes da tarefa em que
    estão trabalhando estejam prontos.
</p>
<h3>
    <a id="Java" name="Java">Um exemplo de TDD em Java</a>
</h3>
<p>
    Segue um exemplo simples de desenvolvimento dirigido por testes. O programa que estamos escrevendo é um formatador de
    texto que pode obter strings arbitrárias e centralizá-las horizontalmente em uma página. A primeira coluna mostra os
    testes, e a segunda coluna mostra o código de produção. O teste é sempre escrito e compilado primeiro. Se a compilação
    falhar, então será acrescentado código de produção para compilar com êxito. Então o teste é executado para ver se
    passa. Se o teste falhar, então código de produção é acrescentado para fazer o teste passar. Se o teste passar, então
    um novo teste é acrescentado.
</p>
<table width="100%" border="1">
    <tbody>
        <tr>
            <td>
                <div align="center">
                    <font size="-1"><i><b>Primeiro escrevemos o teste</b></i></font>
                </div>
            </td>
            <td>
                <div align="center">
                    <font size="-1"><i><b>Então escrevemos o código de produção</b></i></font>
                </div>
            </td>
        </tr>
    </tbody>
    <tbody>
        <tr>
            <td>
            </td>
            <td>
            </td>
        </tr>
        <tr>
            <td>
            </td>
            <td>
            </td>
        </tr>
        <tr>
            <td>
            </td>
            <td>
            </td>
        </tr>
        <tr>
            <td>
            </td>
            <td>
            </td>
        </tr>
        <tr>
            <td>
            </td>
            <td>
            </td>
        </tr>
    </tbody>
</table>
<h3>
    <a id="Benefits" name="Benefits">Quais são os benefícios do TDD?</a>
</h3>
<ul>
    <li>
        <b>Cobertura de Teste.</b> Se você seguir as regras do TDD, então praticamente 100% das linhas de código de
        produção em seu programa estarão cobertos por testes de unidade. Isto não cobre 100% dos caminhos no código, mas
        certifica que praticamente todas as linhas são executadas e testadas.<br />
    </li>
    <li>
        <b>Repetitividade dos Testes</b>. Os testes podem ser executados a qualquer hora que você quiser. Isto é
        especialmente útil após você ter feito alterações no código de produção. Você pode executar os testes para
        certificar-se que o código existente não parou de funcionar. Visto que os testes lhe dão segurança você pode ter
        coragem de fazer alterações que de outra forma seriam muito arriscadas de fazer.<br />
    </li>
    <li>
        <b>Documentação</b>. Os testes descrever o seu entendimento de como o código deve se comportar. Eles também
        descrevem a API. Por isso, os testes são uma forma de documentação. Os testes de unidade são normalmente muito
        simples e, portanto, são fáceis de entender. Além disso, são inequívocos e executáveis. Finalmente, se os testes
        forem executados todas às vezes que qualquer alteração no código for feita, eles nunca ficarão obsoletos.<br />
    </li>
    <li>
        <b>Design da API</b>. Quando você escreve os testes primeiro, você se coloca na posição de um usuário da API de seu
        programa. Isso só pode lhe ajudar a executar um melhor design da API. Sua primeira preocupação, ao escrever os
        testes, é tornar mais fácil e conveniente o uso dessa API.<br />
    </li>
    <li>
        <b>Design do Sistema</b>. Um módulo que é independentemente testável é um módulo que está desacoplado do resto do
        sistema. Quando você escrever os testes primeiro, você automaticamente desacopla os módulos que você está testando.
        Isso tem um profundo efeito positivo na qualidade geral do design do sistema.<br />
    </li>
    <li>
        <b>Depuração Reduzida</b>. Quando você se move de acordo com os minúsculos passos recomendados pelo TDD, quase
        nunca é necessário usar o depurador. O tempo de depuração é reduzido extremamente.<br />
    </li>
    <li>
        <b>O seu código acabou de funcionar!</b> se você observar uma equipe de desenvolvedores que estão praticando TDD,
        você perceberá que cada par de desenvolvedores teve seu código funcionando a um minuto atrás. Não importando quando
        você faz a observação! A um minuto ou mais atrás, cada par executou seu código, e ele passou em todos os testes.
        Sendo assim, você nunca estará muito longe de fazer o sistema funcionar.<br />
    </li>
</ul>
<h3>
    <a id="Costs" name="Costs">Quais são os custos do TDD?</a>
</h3>
<ul>
    <li>
        A programação em pequenos ciclos pode parecer ineficaz. Os programadores muitas vezes acham frustrante trabalhar em
        incrementos tão pequenos que lhes permitam saber o resultado do teste. Às vezes parece que não vale a pena dar um
        passo tão pequeno.<br />
    </li>
    <li>
        Muito código de teste é produzido. Não é raro que o total de código de teste exceda em muito o total de código de
        produção. Este código tem que ser mantido a um custo significativo.<br />
    </li>
    <li>
        Bastante tempo é gasto mantendo os testes sincronizados com o código de produção. Os programadores, por vezes acham
        que o tempo gasto para manter os testes funcionando e bem estruturados é um tempo que não está sendo gasto com os
        desejos do cliente.<br />
    </li>
</ul>
<h3>
    <a id="Principles" name="Principles">Quais princípios de teste eu devo empregar?</a>
</h3>
<ul>
    <li>
        <b>Isolamento</b>. Ao escrever um teste de unidade para um módulo, considere se você deseja que o módulo invoque
        outros módulos. Se não desejar, então isole o módulo com interfaces. Por exemplo, suponha que você está testando um
        módulo que interage com o banco de dados. O teste não tem nada a ver com o banco de dados; ele simplesmente testa a
        forma que o módulo manipula o banco de dados. Então você isola o módulo, do banco de dados, criando uma interface
        que represente o banco de dados para que o módulo use. Então, para os propósitos do teste, você implementa a
        interface com um stub de teste. Este tipo de isolamento diminui consideravelmente a quantidade de acoplamento, em
        todo o sistema.
    </li>
</ul>
<p>
    <img height="166" alt="" src="./../../../xp/guidances/guidelines/resources/xp_tdd_guid_database.jpg" width="403" />
</p>
<ul>
    <li>
        <b>Simplicidade</b> Mantenha os ciclos de edição, compilação e testes extremamente curtos: menos de cinco minutos
        em média. Escreva somente o código de produção necessário para fazer os testes atuais passarem. Tente não escrever
        código que irá fazer futuros testes passarem. Em todos os ciclos de edição, compilação e testes, mantenha o código
        o mais simples possível.<br />
    </li>
    <li>
        <b>Aumento da Generalidade</b>. À medida que você adiciona casos de teste, o código de produção deve tornar-se mais
        e mais geral. Tente sempre aumentar a generalidade. Por exemplo, considere o seguinte caso de teste:<br />
        <p>
            Poderíamos fazer esse teste passar escrevendo:
        </p>
    </li>
</ul>
<p>
    Isto está de acordo com o princípio de simplicidade. Se <font size="3"><tt>testThreeSquared</tt></font> fosse o único
    caso de teste que importasse então esta implementação estaria correta. É claro que sabemos que está incorreta, mas na
    sua forma atual ele verifica que o caso de teste realmente passa quando se espera. Agora suponha que acrescentemos um
    novo caso de teste:
</p>
<p>
    Poderíamos fazê-lo passar, alterando a função square da seguinte forma:
</p>
<p>
    Mesmo passando no teste, ela viola a regra de tornar o código mais geral. Para tornar o código mais geral, temos que
    retornar a raiz do argumento.
</p>
<p>
    Esta solução passa em todos os testes, é simples, e aumenta a generalidade da solução.
</p>
<ul>
    <li>
        <b>Casos Incomuns e Condições Limítrofes</b>. Os casos incomuns e as condições limítrofes são implementados no
        código de produção com declarações if ou outras estruturas similares de decisão. Não escreva estas declarações a
        menos que você tenha um teste de unidade que esteja falhando porque elas não existem. Por exemplo, digamos que você
        está calculando um pagamento semanal para um empregado horista. 
        <p>
            O código que permite ele passar tem esta aparência:
        </p>
    </li>
</ul>
<p>
    Agora vamos dizer que queremos calcular o pagamento de horas extras. Qualquer hora após as oito é cobrada uma hora e
    meia. A primeira coisa que fazemos é adicionar o novo caso de teste falho:
</p>
<p>
    <i>Então</i> fazemos o caso de teste passar, alterando o código de produção.
</p>
<p>
    Evite acrescentar qualquer <font size="3"><tt>if, while, for, do</tt></font> ou qualquer outro tipo de condicional sem
    um caso de teste falhar. Lembre-se de acrescentar casos de teste para cada condição limítrofe.
</p>
<ul>
    <li>
        <b>Teste Tudo Que Possa Falhar</b>. Do mesmo modo, não se preocupe em testar coisas que não podem falhar. Por
        exemplo, normalmente é infrutífero testar accessors e mutators simples. 
        <p>
            Acessors e mutators normalmente não podem falhar. Por isso não há razão para testá-los. Um julgamento claro tem
            que ser aplicado para usar esta regra. Você será tentado a evitar um teste de unidade necessário, alegando que
            o código não pode falhar. Você saberá que caiu neste hábito quando começar a encontrar erros nos métodos que
            você pensava que não podiam falhar.
        </p>
    </li>
    <li>
        <b>Mantenha os Dados Dos Testes no Código</b>. Às vezes é tentador colocar dados de teste em um arquivo,
        especialmente quando a entrada de um módulo é um arquivo. Entretanto, o melhor lugar para os dados do teste é no
        próprio código do teste de unidade. Por exemplo, suponha que temos uma função que conte a quantidade de caracteres
        em um arquivo. A assinatura desta função é: 
        <p>
            Para manter os dados de teste no código do teste de unidade, o teste deve ser escrito desta forma:
        </p>
    </li>
</ul>
<p>
    Isto mantém todos os dados relevantes para o teste em um só lugar.
</p>
<ul>
    <li>
        <b>Remoção de Testes</b>. Algumas vezes você vai escrever testes que são úteis por um tempo, mas tornam-se
        redundantes à medida que outros testes assumam o seu papel. Não tenha medo de remover antigos testes redundantes.
        Mantenha a suíte de testes o menor possível sem comprometer a cobertura.
    </li>
</ul>
<ul>
    <li>
        <b>Mantenha a Duração do Teste Curta</b>. A eficácia dos testes depende da conveniência. A eficácia dos testes
        depende da conveniência. Sendo assim, é muito importante manter a duração dos testes bem curta. Em um sistema
        grande, isto significa decompor os testes.<br />
        <br />
        Ao trabalhar em um módulo em particular, você vai querer escolher os testes que sejam relevantes para esse módulo e
        os módulos circundantes. Mantenha a duração do teste bem abaixo de um minuto. Dez segundos é frequentemente muito
        tempo.<br />
        <br />
        Ao fazer check-in, de um módulo, execute uma suíte que teste todo o sistema, mas que não dure mais do que 10
        minutos para ser executada. Isto pode significar que você terá que extrair alguns dos testes mais demorados.<br />
        <br />
        Execute a totalidade dos testes no sistema, todas as noites. Mantenha o tempo de execução suficientemente pequeno
        para que eles possam ser executados mais de uma vez antes do amanhecer, para os casos onde haja problemas que
        obriguem outra execução.
    </li>
</ul>
<h3>
    <a id="GUIS" name="GUIS">Como posso testar GUIs?</a>
</h3>
<p>
    O truque para escrever testes de unidade para GUIs é a separação e o desacoplamento. Separe o código da GUI em três
    camadas, normalmente chamadas <b>Modelo</b>, <b>Visão</b> e <b>Apresentador</b>:
</p>
<ul>
    <li>
        O <b>Modelo</b> interpreta as regras de negócio dos itens que serão exibidos na tela. Todas as políticas relevantes
        relacionadas ao negócio são implementadas neste módulo. Por isso, este módulo é fácil de testar somente com base em
        suas entradas e saídas.<br />
    </li>
    <li>
        O <b>Apresentador</b> entende como os dados serão apresentados e como o usuário irá interagir com estes dados. Ele
        sabe que existem botões, caixas de verificação, campos de texto, etc. Ele sabe que às vezes os botões precisam ser
        desativados (esmaecidos) e os campos de texto não editáveis. Ele sabe, em um nível mecânico, como os dados são
        exibidos e como as interações ocorrem. Entretanto, ele não sabe nada sobre a real API da GUI. Por exemplo, se você
        estiver escrevendo uma GUI Java Swing, o Apresentador não usará nenhuma das classes swing. Ao invés, ele envia
        mensagens para a Visão cuidar da real exibição e interação. Sendo assim, o Apresentador pode ser testado,
        novamente, somente com base em suas entradas vindas do Modelo e suas saídas para a Visão.<br />
    </li>
    <li>
        A <b>Visão</b> compreende a API da GUI. Ela não toma decisões de validação, seleção ou políticas. Ela tem
        praticamente inteligência zero. Ela simplesmente une a interface usada pelo Apresentador à API da GUI. Ela pode ser
        testada pela verificação das conexões. Os testes percorrem as estruturas de dados da GUI, certificando-se que os
        botões, campos de texto e caixas de verificação apropriados foram criados. Os testes enviam eventos para os widgets
        da GUI e certificam que as chamadas adequadas foram invocadas.
    </li>
</ul>
<h3>
    <a id="Embedded" name="Embedded">Como posso testar sistemas incorporados?</a>
</h3>
<p>
    Alguns softwares são escritos para controlar o hardware. Você pode testar estes softwares escrevendo um simulador de
    hardware. Os testes definem vários estados no simulador de hardware e então conduzem o sistema para manipular o
    hardware. Finalmente, os testes consultam a simulação para assegurar que o hardware foi conduzido ao estado final
    correto.
</p>
<h3>
    <a id="Concurrency" name="Concurrency">Como posso testar concorrência?</a>
</h3>
<p>
    Alguns softwares são re-entrantes ou concorrentes. Condições de concorrência podem tornar o comportamento do software
    indeterminístico. Existem algumas falhas que podem ser tanto severas quanto fortemente dependentes de temporização e
    ordem dos eventos. Softwares que funcionam 99,999% do tempo, podem falhar em 0,001% devido a problemas de concorrência.
    Encontrar estes problemas é um desafio.
</p>
<p>
    Normalmente testes Monte Carlo exaustivos são usados para tentar direcionar o sistema através da maioria dos estados
    possíveis.
</p>
<p>
    Quando os problemas de concorrência são descobertos, os testes podem ser escritos de forma que direcionem o sistema
    para o estado de falha e, depois, comprove a falha. Então, o problema pode ser reparado e o teste continuar na suíte de
    testes como um teste de regressão.
</p>
<h3>
    <a id="Database" name="Database">Como posso testar transações de banco de dados?</a>
</h3>
<p>
    Quase sempre a melhor forma de fazer isso é criar uma interface que represente a base de dados. Cada caso de teste pode
    implementar essa interface e fingir ser a base de dados, fornecendo os seus próprios dados e interpretando as chamadas
    feitas pelo módulo em teste. Isso evita que os dados de teste sejam realmente escritos e lidos na base de dados. Isto
    também permite que o código de teste force condições de falha que de outra forma seriam difíceis de simular.
</p>
<p>
    Veja: <a href="http://c2.com/cgi/wiki?MockObject" target="_blank">http://c2.com/cgi/wiki?MockObject</a>
</p>
<h3>
    <a id="Servlets" name="Servlets">Como posso testar servlets?</a>
</h3>
<p>
    Os servlets são simplesmente tubos através dos quais os dados do formulário passam para um programa e o HTML retorna. O
    truque para testar um servlet é separar o programa do tubo. Mantenha o código do servlet o menor possível. Coloque o
    seu programa nas velhas classes planas que não derivem de Servlets. Então você poderá testar estas velhas classes
    planas como de costume. Se o próprio servlet for bem pequeno, pode ser tão simples que não necessite de testes.
</p>
<p>
    Certamente, você também poderá criar o seu próprio invocador de servlets ou usar uma versão de código aberto. Esses
    programas agem como servidores web e disparam os servlets para você. Você passa os dados do formulário para eles e eles
    retornam o HTML para você.
</p>
<p>
    Veja:
</p>
<blockquote>
    <a href="http://c2.com/cgi/wiki?JunitServlet" target="_blank">http://c2.com/cgi/wiki?JunitServlet</a><br />
    <a href="http://c2.com/cgi/wiki?ServletTesting" target="_blank">http://c2.com/cgi/wiki?ServletTesting</a><br />
    <a href="http://strutstestcase.sourceforge.net/" target="_blank">http://strutstestcase.sourceforge.net/</a>
</blockquote>
<h3>
    <a id="WebPages" name="WebPages">Como posso testar páginas Web?</a>
</h3>
<p>
    Um documento HTML é quase um documento XML. Existe uma ferramenta que permite que você pesquise um documento HTML como
    se fosse um documento XML. Esta ferramenta é chamada de HTTPUnit. Usando esta ferramenta, você poderá escrever testes
    que inspecionem o conteúdo de um documento HTML sem se preocupar com espaços em branco ou questões de formatação. Outra
    ferramenta chamada HTMLUnit também faz algo semelhante. A HTMLUnit inclui suporte para testar páginas HTML com
    JavaScript embutido.
</p>
<p>
    Veja:
</p>
<blockquote>
    <a href="http://httpunit.sourceforge.net/" target="_blank">http://httpunit.sourceforge.net/</a><br />
    <a href="http://htmlunit.sourceforge.net/" target="_blank">http://htmlunit.sourceforge.net/</a><br />
</blockquote>
<p>
    <br />
</p></td>
</tr>
</table>
</div>
<table class="copyright" border="0" cellspacing="0" cellpadding="0">
<tr>
<td class="copyright">Copyright (c) 2002, 2006 IBM Corporation e Object Mentor. Todos os Direitos Reservados. <br /> Este programa e o material que o acompanha são disponibilizados sob os termos da Eclipse Public License v1.0, que acompanha esta distribuição e está disponível em <a href="http://www.eclipse.org/legal/epl-v10.html" target="_blank">http://www.eclipse.org/legal/epl-v10.html.</a> <br /> Colaboradores: IBM Corporation e Object Mentor - implementação inicial<br /></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
				contentPage.onload();
			</script>
</html>
