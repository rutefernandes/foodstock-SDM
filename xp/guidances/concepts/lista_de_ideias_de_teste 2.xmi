<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-S5hMFvvt4rKI1zSQHduA5A" name="test-ideas_list,8.834380241450745E-306" guid="-S5hMFvvt4rKI1zSQHduA5A" changeDate="2009-02-26T21:48:18.687-0300" version="1.0.0">
  <mainDescription>&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introdução&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    As informações usadas no design de testes são obtidas de várias fontes: modelos de design, interfaces classificadoras,&#xD;
    gráficos de estado e o próprio código. Em algum momento, essa fonte de informações documentais deve ser transformada em&#xD;
    testes executáveis:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        entradas específicas fornecidas ao software sob teste&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        em uma determinada configuração de hardware e software&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        definida inicialmente em um estado conhecido&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        com resultados específicos esperados&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    É possível ir diretamente da fonte de informações documentais aos testes executáveis, mas é útil acrescentar uma etapa&#xD;
    intermédia. Nesta etapa, as ideias de teste são escritas em uma &lt;i>Lista de Ideias de Teste&lt;/i>, que é usada para criar&#xD;
    os testes executáveis.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;TestIdeas&quot; name=&quot;TestIdeas&quot;>O que são as ideias de teste?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Uma ideia de teste (também conhecida como um requisito de teste) é uma declaração resumida de um teste que pode ser&#xD;
    realizado. Como simples exemplo, vamos considerar uma função que calcula a raiz quadrada e que tenha as seguintes&#xD;
    ideias de teste:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        fornecer um número que é inferior a zero como entrada&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        fornecer zero como entrada&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        testar um número que seja um quadrado perfeito, tal como 4 ou 16 (o resultado é exatamente 2 ou 4?)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Cada uma dessas ideias poderia facilmente ser convertida em um teste executável com descrições exatas das entradas e&#xD;
    resultados esperados.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Existem duas vantagens para esta forma intermediaria menos específica:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        As ideias de teste são mais fáceis de revisar e entender do que os testes completos - é mais fácil entender o&#xD;
        raciocínio por trás delas&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        as ideias de teste suportam testes mais poderosos, descritos abaixo sob o título &lt;a&#xD;
        href=&quot;#TestDesignUsingTheList&quot;>Design de Teste Usando a Lista&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Os exemplos da raiz quadrada descrevem as entradas, mas as ideias de teste podem descrever qualquer elemento de um&#xD;
    teste executável. Por exemplo, &quot;imprimir em uma LaserJet IIIP&quot; descreve um aspecto do ambiente de teste, a ser usado em&#xD;
    um teste, tal como &quot;testar com o banco de dados completo&quot;; Entretanto, estas últimas idéias de teste são muito&#xD;
    incompletas em si: Imprimir &lt;b>o que&lt;/b> na impressora? Fazer &lt;b>o que&lt;/b> com o banco de dados completo? Entretanto,&#xD;
    elas asseguram que ideias importantes não foram esquecidas; ideias que serão descritas com mais detalhes&#xD;
    posteriormente, no design de testes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As ideias de teste são muitas vezes baseadas em modelos de falhas; noções de quais falhas são plausíveis no software e&#xD;
    como elas podem ser melhor descobertas. Por exemplo, considere as fronteiras. É seguro assumir que a função raiz&#xD;
    quadrada pode ser implementada tal como:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &amp;nbsp; &amp;nbsp; double sqrt(double x) {&lt;br />&#xD;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (x &amp;lt; 0)&lt;br />&#xD;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // signal error&lt;br />&#xD;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ...&lt;br />&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Também é plausível que o &lt;font size=&quot;+0&quot;>&amp;lt;&lt;/font> seja digitado incorretamente como &lt;font size=&quot;+0&quot;>&amp;lt;=&lt;/font>. As&#xD;
    pessoas normalmente cometem este tipo de erro, por isso é importante verificar. A falha não pode ser detectada com&#xD;
    &lt;font size=&quot;+0&quot;>X&lt;/font> tendo o valor &lt;font size=&quot;+0&quot;>2&lt;/font>, porque tanto a expressão incorreta (&lt;font&#xD;
    size=&quot;+0&quot;>X&amp;lt;= 0&lt;/font>) como a expressão correta (&lt;font size=&quot;+0&quot;>X&amp;lt;0&lt;/font>) seguirão pelo mesmo ramo da&#xD;
    declaração &lt;font size=&quot;+0&quot;>if&lt;/font>. Da mesma forma, se &lt;font size=&quot;+0&quot;>X&lt;/font> tiver o valor &lt;font&#xD;
    size=&quot;+0&quot;>-5&lt;/font>, a falha não será encontrada. A única forma de encontrá-la é atribuir a &lt;font size=&quot;+0&quot;>X&lt;/font> o&#xD;
    valor &lt;font size=&quot;+0&quot;>0&lt;/font>, o que justifica a segunda ideia de teste.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Neste caso, o modelo de falha é explícito. Em outros casos, é implícito. Por exemplo, sempre que um programa manipula&#xD;
    uma estrutura encadeada, é bom testá-lo com uma estrutura circular. É possível que muitas falhas possam conduzir a uma&#xD;
    estrutura circular mal tratada. Para os propósitos do teste, elas não precisam ser enumeradas - é suficiente saber que&#xD;
    qualquer falha é o bastante para que valha a pena executar o teste.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Os links a seguir contêm informações sobre como obter ideias de teste de diferentes tipos de modelos de falha. Os dois&#xD;
    primeiros são modelos de falha explícitos; o último usa um implícito.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot;&#xD;
        href=&quot;./../../../xp/guidances/guidelines/ideias_de_teste_para_valores_limitrofes_e_booleanos_29731344.html&quot;&#xD;
        guid=&quot;1.7150344523489172E-305&quot;>Guideline: Ideias de Teste Para Valores Limítrofes e Booleanos&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot;&#xD;
        href=&quot;./../../../xp/guidances/guidelines/ideias_de_teste_para_chamadas_de_metodos_F55E5A9E.html&quot;&#xD;
        guid=&quot;8.5657170364036E-306&quot;>Guideline: Ideias de Teste Para Chamadas de Métodos&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../xp/guidances/concepts/catalogo_de_ideias_de_teste_F649734.html&quot;&#xD;
        guid=&quot;1.2384224477983028E-305&quot;>Concept: Catálogo de Ideias de Teste&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Estes modelos de falha podem ser aplicados em diversos artefatos. Por exemplo, o primeiro descreve o que fazer com&#xD;
    expressões Booleanas. Tais expressões podem ser encontradas no código, em condições de guarda, em gráficos de estado e&#xD;
    diagramas de sequência e em descrições em linguagem natural dos comportamentos do método (tal como você pode encontrar&#xD;
    em uma API publicada).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Ocasionalmente também é útil ter diretrizes para artefatos específicos. Veja &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../xp/guidances/guidelines/ideias_de_teste_para_graficos_de_estado_e_diagramas_de_fluxo_AD59D4ED.html&quot;&#xD;
    guid=&quot;1.0347051690476123E-305&quot;>Guideline: Ideias de Teste para Gráficos de Estado e Diagramas de Fluxo&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Uma Lista especial de Ideias de Teste pode conter ideias de teste de muitos modelos de falha, e os modelos de falha&#xD;
    podem ser derivados de mais de um artefato.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;TestDesignUsingTheList&quot; name=&quot;TestDesignUsingTheList&quot;>Design de Testes Usando a Lista&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Vamos supor que você esteja projetando testes para um método que pesquise uma string em uma coleção sequencial. Ele&#xD;
    pode tanto considerar a caixa ou ignorá-la em sua pesquisa, e retornar a posição da primeira correspondência encontrada&#xD;
    ou -1 se nenhuma for encontrada.&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &amp;nbsp; &amp;nbsp; int Collection.find(String string, Boolean ignoreCase);&lt;br />&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Aqui estão algumas ideias de teste para este método:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        correspondência encontrada na primeira posição&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        correspondência encontrada na última posição&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        nenhuma correspondência encontrada&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        duas ou mais correspondências encontradas na coleção&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        com a caixa ignorada a correspondência foi encontrada, mas não seria se a caixa fosse considerada&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        com a caixa considerada, uma correspondência exata foi encontrada&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        com a caixa considerada, não foi encontrada uma string que caso a caixa fosse ignorada ela seria&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    Seria simples implementar estes sete testes, um para cada ideia de teste. Entretanto, diferentes ideias de teste podem&#xD;
    ser combinadas em um único teste. Por exemplo, o teste a seguir &lt;i>satisfaz&lt;/i> as ideias de teste 2, 6 e 7:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;p>&#xD;
        Inicialização: a coleção é inicializada com [ &quot;alvorada&quot;, &quot;Alvorada&quot;]&lt;br />&#xD;
        invocação: collection.find(&quot;Alvorada&quot;, false)&lt;br />&#xD;
        Resultado esperado: o valor de retorno é 1 (seria 0 se &quot;alvorada&quot; não fosse desprezada)&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Fazer as ideias de teste não específicas torna-as mais fáceis de combinar.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    É possível satisfazer todas as ideias de teste com três testes. Porque três testes, que satisfazem as sete ideias de&#xD;
    teste, são melhores do que sete testes separados?&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Quando você cria uma grande quantidade de testes simples, é comum criar o teste N+1, copiando o teste N e&#xD;
        ajustando-o apenas o suficiente para satisfazer a nova ideia de teste. The result, especially in more complex&#xD;
        software, is that test N+1 probably exercises the program in almost the same way as test N. It takes almost exactly&#xD;
        the same path through the code.&lt;br />&#xD;
        &lt;br />&#xD;
        Uma menor quantidade de testes, cada um satisfazendo várias ideias de teste, não permite uma abordagem &quot;copiar e&#xD;
        adaptar&quot;. Cada teste será um pouco diferente do último, exercitando o código de formas diferentes e percorrendo&#xD;
        caminhos diferentes.&lt;br />&#xD;
        &lt;br />&#xD;
        Por que isso seria melhor? Se a Lista de Ideias de Teste estivesse completa, com uma ideia de teste para cada falha&#xD;
        no programa, não seria importante a forma como você iria escrever os testes. Mas sempre faltam algumas ideias de&#xD;
        teste na lista que poderiam encontrar erros. Se cada teste fizer coisas muito diferentes do último - acrescentando&#xD;
        variedade aparentemente desnecessária - você aumenta a chance de um dos testes encontrar um erro escondido. Com&#xD;
        efeito, os testes menores e mais complexos aumentam a chance de satisfazer uma ideia de teste que você não sabia&#xD;
        que era necessária.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Às vezes quando você está criando testes mais complexos, novas ideias de teste vêm à mente. Isto acontece em menor&#xD;
        frequência com testes simples, porque grande parte do que você está fazendo é exatamente igual ao que você fez no&#xD;
        último teste, o que embota sua mente.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Entretanto, existem razões para não criar testes complexos.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Se cada teste satisfizer uma única ideia de teste e o teste para a ideia 2 falhar, você saberá imediatamente a&#xD;
        causa mais provável: o programa não tratou uma correspondência na última posição. Se um teste satisfizer as ideias&#xD;
        2, 6, e 7 então isolar a falha será mais difícil.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Os testes complexos são mais difíceis de entender e manter. A intenção do teste é menos evidente.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Os testes complexos são mais difíceis de criar. A construção de um teste que satisfaça cinco ideias de teste,&#xD;
        normalmente leva mais tempo do que a construção de cinco testes que satisfaçam cada uma. Aliás, é muito mais fácil&#xD;
        cometer erros - pensar que está satisfazendo todas as cinco quando está apenas satisfazendo quatro.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Na prática, você deve encontrar um equilíbrio razoável entre a complexidade e a simplicidade. Por exemplo, os primeiros&#xD;
    testes que você submeteu o software (normalmente os testes fumaça) devem ser simples, fáceis de entender e manter e&#xD;
    destinados a capturar os problemas mais óbvios. Os testes posteriores devem ser mais complexos, mas não tão complexos&#xD;
    que não possam ser mantidos.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Após terminar um conjunto de testes, é bom verificar os enganos característicos de design de teste discutidos em &lt;a&#xD;
    class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../xp/guidances/concepts/testes_de_desenvolvedor_E45BC54E.html#TestDesignMistakes&quot;&#xD;
    guid=&quot;4.085829182735815E-305&quot;>Concept: Testes de Desenvolvedor&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;UsingTestIdeasBeforeTest&quot; name=&quot;UsingTestIdeasBeforeTest&quot;>Usando as Ideias de Teste Antes da Execução dos&#xD;
    Testes&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Uma Lista de Ideias de Teste é útil para revisões e inspeções nos artefatos de design. Por exemplo, considere esta&#xD;
    parte de um modelo de design que mostra a associação entre as classes Departamento e Empregado.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;45&quot; alt=&quot;&quot; src=&quot;resources/tstidslst-img1.gif&quot; width=&quot;223&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Figura 1: Associação entre as Classes Departamento e Empregado&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As regras para a criação de ideias de teste a partir de um modelo desse tipo iriam lembrar-lhe de considerar o caso de&#xD;
    um departamento ter muitos empregados. Ao percorrer um design perguntando &quot;e se, neste ponto, o departamento tiver&#xD;
    muitos empregados?&quot;, você poderá descobrir erros de design ou análise. Por exemplo, você pode perceber que só um&#xD;
    empregado pode ser transferido entre departamentos por vez. Isto pode ser um problema se a corporação está propensa a&#xD;
    executar reorganizações onde muitos trabalhadores necessitem ser transferidos.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Tais falhas, casos em que uma possibilidade foi esquecida, são chamadas de &lt;i>falhas de omissão&lt;/i>. Tal como as&#xD;
    próprias falhas, você provavelmente omitiu os testes que detectam estas falhas, do seu esforço de testes. Por exemplo,&#xD;
    veja &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../xp/guidances/supportingmaterials/referencias_sobre_xp_e_processo_agil_BA6A741C.html&quot;&#xD;
    guid=&quot;6.191633934532389E-306&quot;>[GLA81]&lt;/a>, &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../xp/customcategories/referencias_7226794B.html#OST84&quot; guid=&quot;_mtcqtmE-EdqnIZeW8YpHcA&quot;>[OST84]&lt;/a>, &lt;a&#xD;
    href=&quot;./../../../xp/customcategories/referencias_7226794B.html#BAS87&quot; guid=&quot;_mtcqtmE-EdqnIZeW8YpHcA&quot;>[BAS87]&lt;/a>, &lt;a&#xD;
    href=&quot;./../../../xp/customcategories/referencias_7226794B.html#MAR00&quot; guid=&quot;_mtcqtmE-EdqnIZeW8YpHcA&quot;>[MAR00]&lt;/a> e&#xD;
    outros estudos que mostram a frequência em que falhas e omissões só aparecem na implantação.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O papel dos testes nas atividades de design é mais discutido em &lt;a class=&quot;elementLinkWithType&quot;&#xD;
    href=&quot;./../../../xp/guidances/concepts/design_teste-primeiro_73AA5ED9.html&quot; guid=&quot;6.556259235358794E-306&quot;>Concept:&#xD;
    Design Teste-Primeiro&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;TestIdeasTraceability&quot; name=&quot;TestIdeasTraceability&quot;>Ideias de Teste e Rastreabilidade&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A rastreabilidade é uma questão de análise. O seu benefício vale mais que o custo de mantê-la? Esta questão tem que ser&#xD;
    considerada durante a Atividade: Definir as Necessidades de Avaliação e Rastreabilidade.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Quando a rastreabilidade vale a pena, é convencional rastrear os testes com os artefatos que os inspiraram. Por&#xD;
    exemplo, você poderia ter uma rastreabilidade entre uma API e seus testes. Se a API mudar, você saberá quais testes&#xD;
    terão que ser alterados. Se o código (que implementa a API) mudar, você saberá quais testes deverão ser executados. Se&#xD;
    um teste lhe confundir, você poderá encontrar a API a que ele se destina.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A Lista de Ideias de Teste acrescenta outro nível de rastreabilidade. Você pode rastrear um teste à ideia de teste que&#xD;
    ele satisfaz e, então, ao artefato original.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
