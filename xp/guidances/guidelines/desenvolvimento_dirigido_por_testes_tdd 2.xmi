<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="--mfSlXK1-6fNvrGyv8C2Eg" name="test_driven_development_tdd,3.9254165491375454E-306" guid="--mfSlXK1-6fNvrGyv8C2Eg" changeDate="2006-11-21T20:17:42.164-0300" version="1.0.0">
  <mainDescription>&lt;a id=&quot;XE_xp__test_driven_development&quot; name=&quot;XE_xp__test_driven_development&quot;>&lt;/a>&lt;a id=&quot;XE_test_driven_development__in_xp&quot;&#xD;
name=&quot;XE_test_driven_development__in_xp&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    Tópicos&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#WhatIs&quot;>O que é TDD?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Java&quot;>Um exemplo de TDD em Java&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Benefits&quot;>Quais são os benefícios do TDD?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Costs&quot;>Quais são os custos do TDD?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Principles&quot;>Quais princípios de teste eu devo empregar?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#GUIS&quot;>Como posso testar GUIs?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Embedded&quot;>Como posso testar sistemas incorporados?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Concurrency&quot;>Como posso testar concorrência?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Database&quot;>Como posso testar transações de banco de dados?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#Servlets&quot;>Como posso testar servlets?&lt;/a>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;#WebPages&quot;>Como posso testar páginas Web?&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;WhatIs&quot; name=&quot;WhatIs&quot;>O que é TDD?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    TDD é a prática de escrever testes de unidade e código de produção concorrentemente e com alto nível de detalhe. Um par&#xD;
    de programadores escreve primeiro uma pequena parte de um teste de unidade e, em seguida, escrevem código de produção&#xD;
    suficiente apenas para fazer este teste de unidade compilar e executar. Então eles escrevem um pouco mais do teste e&#xD;
    acrescentam código de produção suficiente para fazer com que esse novo teste compile e execute com sucesso. Este ciclo&#xD;
    pode durar de 30 segundos a cinco minutos. Raramente alcança dez minutos. Em cada ciclo, os testes vêm em primeiro&#xD;
    lugar. Uma vez que um teste de unidade esteja pronto, eles constroem outro até que todos os testes da tarefa em que&#xD;
    estão trabalhando estejam prontos.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Java&quot; name=&quot;Java&quot;>Um exemplo de TDD em Java&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Segue um exemplo simples de desenvolvimento dirigido por testes. O programa que estamos escrevendo é um formatador de&#xD;
    texto que pode obter strings arbitrárias e centralizá-las horizontalmente em uma página. A primeira coluna mostra os&#xD;
    testes, e a segunda coluna mostra o código de produção. O teste é sempre escrito e compilado primeiro. Se a compilação&#xD;
    falhar, então será acrescentado código de produção para compilar com êxito. Então o teste é executado para ver se&#xD;
    passa. Se o teste falhar, então código de produção é acrescentado para fazer o teste passar. Se o teste passar, então&#xD;
    um novo teste é acrescentado.&#xD;
&lt;/p>&#xD;
&lt;table width=&quot;100%&quot; border=&quot;1&quot;>&#xD;
    &lt;tbody>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
                &lt;div align=&quot;center&quot;>&#xD;
                    &lt;font size=&quot;-1&quot;>&lt;i>&lt;b>Primeiro escrevemos o teste&lt;/b>&lt;/i>&lt;/font>&#xD;
                &lt;/div>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
                &lt;div align=&quot;center&quot;>&#xD;
                    &lt;font size=&quot;-1&quot;>&lt;i>&lt;b>Então escrevemos o código de produção&lt;/b>&lt;/i>&lt;/font>&#xD;
                &lt;/div>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/tbody>&#xD;
    &lt;tbody>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
        &lt;tr>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
            &lt;td>&#xD;
            &lt;/td>&#xD;
        &lt;/tr>&#xD;
    &lt;/tbody>&#xD;
&lt;/table>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Benefits&quot; name=&quot;Benefits&quot;>Quais são os benefícios do TDD?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Cobertura de Teste.&lt;/b> Se você seguir as regras do TDD, então praticamente 100% das linhas de código de&#xD;
        produção em seu programa estarão cobertos por testes de unidade. Isto não cobre 100% dos caminhos no código, mas&#xD;
        certifica que praticamente todas as linhas são executadas e testadas.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Repetitividade dos Testes&lt;/b>. Os testes podem ser executados a qualquer hora que você quiser. Isto é&#xD;
        especialmente útil após você ter feito alterações no código de produção. Você pode executar os testes para&#xD;
        certificar-se que o código existente não parou de funcionar. Visto que os testes lhe dão segurança você pode ter&#xD;
        coragem de fazer alterações que de outra forma seriam muito arriscadas de fazer.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Documentação&lt;/b>. Os testes descrever o seu entendimento de como o código deve se comportar. Eles também&#xD;
        descrevem a API. Por isso, os testes são uma forma de documentação. Os testes de unidade são normalmente muito&#xD;
        simples e, portanto, são fáceis de entender. Além disso, são inequívocos e executáveis. Finalmente, se os testes&#xD;
        forem executados todas às vezes que qualquer alteração no código for feita, eles nunca ficarão obsoletos.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Design da API&lt;/b>. Quando você escreve os testes primeiro, você se coloca na posição de um usuário da API de seu&#xD;
        programa. Isso só pode lhe ajudar a executar um melhor design da API. Sua primeira preocupação, ao escrever os&#xD;
        testes, é tornar mais fácil e conveniente o uso dessa API.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Design do Sistema&lt;/b>. Um módulo que é independentemente testável é um módulo que está desacoplado do resto do&#xD;
        sistema. Quando você escrever os testes primeiro, você automaticamente desacopla os módulos que você está testando.&#xD;
        Isso tem um profundo efeito positivo na qualidade geral do design do sistema.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Depuração Reduzida&lt;/b>. Quando você se move de acordo com os minúsculos passos recomendados pelo TDD, quase&#xD;
        nunca é necessário usar o depurador. O tempo de depuração é reduzido extremamente.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>O seu código acabou de funcionar!&lt;/b> se você observar uma equipe de desenvolvedores que estão praticando TDD,&#xD;
        você perceberá que cada par de desenvolvedores teve seu código funcionando a um minuto atrás. Não importando quando&#xD;
        você faz a observação! A um minuto ou mais atrás, cada par executou seu código, e ele passou em todos os testes.&#xD;
        Sendo assim, você nunca estará muito longe de fazer o sistema funcionar.&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Costs&quot; name=&quot;Costs&quot;>Quais são os custos do TDD?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A programação em pequenos ciclos pode parecer ineficaz. Os programadores muitas vezes acham frustrante trabalhar em&#xD;
        incrementos tão pequenos que lhes permitam saber o resultado do teste. Às vezes parece que não vale a pena dar um&#xD;
        passo tão pequeno.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Muito código de teste é produzido. Não é raro que o total de código de teste exceda em muito o total de código de&#xD;
        produção. Este código tem que ser mantido a um custo significativo.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Bastante tempo é gasto mantendo os testes sincronizados com o código de produção. Os programadores, por vezes acham&#xD;
        que o tempo gasto para manter os testes funcionando e bem estruturados é um tempo que não está sendo gasto com os&#xD;
        desejos do cliente.&lt;br />&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Principles&quot; name=&quot;Principles&quot;>Quais princípios de teste eu devo empregar?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Isolamento&lt;/b>. Ao escrever um teste de unidade para um módulo, considere se você deseja que o módulo invoque&#xD;
        outros módulos. Se não desejar, então isole o módulo com interfaces. Por exemplo, suponha que você está testando um&#xD;
        módulo que interage com o banco de dados. O teste não tem nada a ver com o banco de dados; ele simplesmente testa a&#xD;
        forma que o módulo manipula o banco de dados. Então você isola o módulo, do banco de dados, criando uma interface&#xD;
        que represente o banco de dados para que o módulo use. Então, para os propósitos do teste, você implementa a&#xD;
        interface com um stub de teste. Este tipo de isolamento diminui consideravelmente a quantidade de acoplamento, em&#xD;
        todo o sistema.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;166&quot; alt=&quot;&quot; src=&quot;resources/xp_tdd_guid_database.jpg&quot; width=&quot;403&quot; />&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Simplicidade&lt;/b> Mantenha os ciclos de edição, compilação e testes extremamente curtos: menos de cinco minutos&#xD;
        em média. Escreva somente o código de produção necessário para fazer os testes atuais passarem. Tente não escrever&#xD;
        código que irá fazer futuros testes passarem. Em todos os ciclos de edição, compilação e testes, mantenha o código&#xD;
        o mais simples possível.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Aumento da Generalidade&lt;/b>. À medida que você adiciona casos de teste, o código de produção deve tornar-se mais&#xD;
        e mais geral. Tente sempre aumentar a generalidade. Por exemplo, considere o seguinte caso de teste:&lt;br />&#xD;
        &lt;p>&#xD;
            Poderíamos fazer esse teste passar escrevendo:&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Isto está de acordo com o princípio de simplicidade. Se &lt;font size=&quot;3&quot;>&lt;tt>testThreeSquared&lt;/tt>&lt;/font> fosse o único&#xD;
    caso de teste que importasse então esta implementação estaria correta. É claro que sabemos que está incorreta, mas na&#xD;
    sua forma atual ele verifica que o caso de teste realmente passa quando se espera. Agora suponha que acrescentemos um&#xD;
    novo caso de teste:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Poderíamos fazê-lo passar, alterando a função square da seguinte forma:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Mesmo passando no teste, ela viola a regra de tornar o código mais geral. Para tornar o código mais geral, temos que&#xD;
    retornar a raiz do argumento.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Esta solução passa em todos os testes, é simples, e aumenta a generalidade da solução.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Casos Incomuns e Condições Limítrofes&lt;/b>. Os casos incomuns e as condições limítrofes são implementados no&#xD;
        código de produção com declarações if ou outras estruturas similares de decisão. Não escreva estas declarações a&#xD;
        menos que você tenha um teste de unidade que esteja falhando porque elas não existem. Por exemplo, digamos que você&#xD;
        está calculando um pagamento semanal para um empregado horista. &#xD;
        &lt;p>&#xD;
            O código que permite ele passar tem esta aparência:&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Agora vamos dizer que queremos calcular o pagamento de horas extras. Qualquer hora após as oito é cobrada uma hora e&#xD;
    meia. A primeira coisa que fazemos é adicionar o novo caso de teste falho:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;i>Então&lt;/i> fazemos o caso de teste passar, alterando o código de produção.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Evite acrescentar qualquer &lt;font size=&quot;3&quot;>&lt;tt>if, while, for, do&lt;/tt>&lt;/font> ou qualquer outro tipo de condicional sem&#xD;
    um caso de teste falhar. Lembre-se de acrescentar casos de teste para cada condição limítrofe.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Teste Tudo Que Possa Falhar&lt;/b>. Do mesmo modo, não se preocupe em testar coisas que não podem falhar. Por&#xD;
        exemplo, normalmente é infrutífero testar accessors e mutators simples. &#xD;
        &lt;p>&#xD;
            Acessors e mutators normalmente não podem falhar. Por isso não há razão para testá-los. Um julgamento claro tem&#xD;
            que ser aplicado para usar esta regra. Você será tentado a evitar um teste de unidade necessário, alegando que&#xD;
            o código não pode falhar. Você saberá que caiu neste hábito quando começar a encontrar erros nos métodos que&#xD;
            você pensava que não podiam falhar.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;b>Mantenha os Dados Dos Testes no Código&lt;/b>. Às vezes é tentador colocar dados de teste em um arquivo,&#xD;
        especialmente quando a entrada de um módulo é um arquivo. Entretanto, o melhor lugar para os dados do teste é no&#xD;
        próprio código do teste de unidade. Por exemplo, suponha que temos uma função que conte a quantidade de caracteres&#xD;
        em um arquivo. A assinatura desta função é: &#xD;
        &lt;p>&#xD;
            Para manter os dados de teste no código do teste de unidade, o teste deve ser escrito desta forma:&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Isto mantém todos os dados relevantes para o teste em um só lugar.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Remoção de Testes&lt;/b>. Algumas vezes você vai escrever testes que são úteis por um tempo, mas tornam-se&#xD;
        redundantes à medida que outros testes assumam o seu papel. Não tenha medo de remover antigos testes redundantes.&#xD;
        Mantenha a suíte de testes o menor possível sem comprometer a cobertura.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;b>Mantenha a Duração do Teste Curta&lt;/b>. A eficácia dos testes depende da conveniência. A eficácia dos testes&#xD;
        depende da conveniência. Sendo assim, é muito importante manter a duração dos testes bem curta. Em um sistema&#xD;
        grande, isto significa decompor os testes.&lt;br />&#xD;
        &lt;br />&#xD;
        Ao trabalhar em um módulo em particular, você vai querer escolher os testes que sejam relevantes para esse módulo e&#xD;
        os módulos circundantes. Mantenha a duração do teste bem abaixo de um minuto. Dez segundos é frequentemente muito&#xD;
        tempo.&lt;br />&#xD;
        &lt;br />&#xD;
        Ao fazer check-in, de um módulo, execute uma suíte que teste todo o sistema, mas que não dure mais do que 10&#xD;
        minutos para ser executada. Isto pode significar que você terá que extrair alguns dos testes mais demorados.&lt;br />&#xD;
        &lt;br />&#xD;
        Execute a totalidade dos testes no sistema, todas as noites. Mantenha o tempo de execução suficientemente pequeno&#xD;
        para que eles possam ser executados mais de uma vez antes do amanhecer, para os casos onde haja problemas que&#xD;
        obriguem outra execução.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;GUIS&quot; name=&quot;GUIS&quot;>Como posso testar GUIs?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    O truque para escrever testes de unidade para GUIs é a separação e o desacoplamento. Separe o código da GUI em três&#xD;
    camadas, normalmente chamadas &lt;b>Modelo&lt;/b>, &lt;b>Visão&lt;/b> e &lt;b>Apresentador&lt;/b>:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        O &lt;b>Modelo&lt;/b> interpreta as regras de negócio dos itens que serão exibidos na tela. Todas as políticas relevantes&#xD;
        relacionadas ao negócio são implementadas neste módulo. Por isso, este módulo é fácil de testar somente com base em&#xD;
        suas entradas e saídas.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        O &lt;b>Apresentador&lt;/b> entende como os dados serão apresentados e como o usuário irá interagir com estes dados. Ele&#xD;
        sabe que existem botões, caixas de verificação, campos de texto, etc. Ele sabe que às vezes os botões precisam ser&#xD;
        desativados (esmaecidos) e os campos de texto não editáveis. Ele sabe, em um nível mecânico, como os dados são&#xD;
        exibidos e como as interações ocorrem. Entretanto, ele não sabe nada sobre a real API da GUI. Por exemplo, se você&#xD;
        estiver escrevendo uma GUI Java Swing, o Apresentador não usará nenhuma das classes swing. Ao invés, ele envia&#xD;
        mensagens para a Visão cuidar da real exibição e interação. Sendo assim, o Apresentador pode ser testado,&#xD;
        novamente, somente com base em suas entradas vindas do Modelo e suas saídas para a Visão.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A &lt;b>Visão&lt;/b> compreende a API da GUI. Ela não toma decisões de validação, seleção ou políticas. Ela tem&#xD;
        praticamente inteligência zero. Ela simplesmente une a interface usada pelo Apresentador à API da GUI. Ela pode ser&#xD;
        testada pela verificação das conexões. Os testes percorrem as estruturas de dados da GUI, certificando-se que os&#xD;
        botões, campos de texto e caixas de verificação apropriados foram criados. Os testes enviam eventos para os widgets&#xD;
        da GUI e certificam que as chamadas adequadas foram invocadas.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Embedded&quot; name=&quot;Embedded&quot;>Como posso testar sistemas incorporados?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Alguns softwares são escritos para controlar o hardware. Você pode testar estes softwares escrevendo um simulador de&#xD;
    hardware. Os testes definem vários estados no simulador de hardware e então conduzem o sistema para manipular o&#xD;
    hardware. Finalmente, os testes consultam a simulação para assegurar que o hardware foi conduzido ao estado final&#xD;
    correto.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Concurrency&quot; name=&quot;Concurrency&quot;>Como posso testar concorrência?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Alguns softwares são re-entrantes ou concorrentes. Condições de concorrência podem tornar o comportamento do software&#xD;
    indeterminístico. Existem algumas falhas que podem ser tanto severas quanto fortemente dependentes de temporização e&#xD;
    ordem dos eventos. Softwares que funcionam 99,999% do tempo, podem falhar em 0,001% devido a problemas de concorrência.&#xD;
    Encontrar estes problemas é um desafio.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Normalmente testes Monte Carlo exaustivos são usados para tentar direcionar o sistema através da maioria dos estados&#xD;
    possíveis.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Quando os problemas de concorrência são descobertos, os testes podem ser escritos de forma que direcionem o sistema&#xD;
    para o estado de falha e, depois, comprove a falha. Então, o problema pode ser reparado e o teste continuar na suíte de&#xD;
    testes como um teste de regressão.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Database&quot; name=&quot;Database&quot;>Como posso testar transações de banco de dados?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Quase sempre a melhor forma de fazer isso é criar uma interface que represente a base de dados. Cada caso de teste pode&#xD;
    implementar essa interface e fingir ser a base de dados, fornecendo os seus próprios dados e interpretando as chamadas&#xD;
    feitas pelo módulo em teste. Isso evita que os dados de teste sejam realmente escritos e lidos na base de dados. Isto&#xD;
    também permite que o código de teste force condições de falha que de outra forma seriam difíceis de simular.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Veja: &lt;a href=&quot;http://c2.com/cgi/wiki?MockObject&quot; target=&quot;_blank&quot;>http://c2.com/cgi/wiki?MockObject&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Servlets&quot; name=&quot;Servlets&quot;>Como posso testar servlets?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Os servlets são simplesmente tubos através dos quais os dados do formulário passam para um programa e o HTML retorna. O&#xD;
    truque para testar um servlet é separar o programa do tubo. Mantenha o código do servlet o menor possível. Coloque o&#xD;
    seu programa nas velhas classes planas que não derivem de Servlets. Então você poderá testar estas velhas classes&#xD;
    planas como de costume. Se o próprio servlet for bem pequeno, pode ser tão simples que não necessite de testes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Certamente, você também poderá criar o seu próprio invocador de servlets ou usar uma versão de código aberto. Esses&#xD;
    programas agem como servidores web e disparam os servlets para você. Você passa os dados do formulário para eles e eles&#xD;
    retornam o HTML para você.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Veja:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;a href=&quot;http://c2.com/cgi/wiki?JunitServlet&quot; target=&quot;_blank&quot;>http://c2.com/cgi/wiki?JunitServlet&lt;/a>&lt;br />&#xD;
    &lt;a href=&quot;http://c2.com/cgi/wiki?ServletTesting&quot; target=&quot;_blank&quot;>http://c2.com/cgi/wiki?ServletTesting&lt;/a>&lt;br />&#xD;
    &lt;a href=&quot;http://strutstestcase.sourceforge.net/&quot; target=&quot;_blank&quot;>http://strutstestcase.sourceforge.net/&lt;/a>&#xD;
&lt;/blockquote>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;WebPages&quot; name=&quot;WebPages&quot;>Como posso testar páginas Web?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Um documento HTML é quase um documento XML. Existe uma ferramenta que permite que você pesquise um documento HTML como&#xD;
    se fosse um documento XML. Esta ferramenta é chamada de HTTPUnit. Usando esta ferramenta, você poderá escrever testes&#xD;
    que inspecionem o conteúdo de um documento HTML sem se preocupar com espaços em branco ou questões de formatação. Outra&#xD;
    ferramenta chamada HTMLUnit também faz algo semelhante. A HTMLUnit inclui suporte para testar páginas HTML com&#xD;
    JavaScript embutido.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Veja:&#xD;
&lt;/p>&#xD;
&lt;blockquote>&#xD;
    &lt;a href=&quot;http://httpunit.sourceforge.net/&quot; target=&quot;_blank&quot;>http://httpunit.sourceforge.net/&lt;/a>&lt;br />&#xD;
    &lt;a href=&quot;http://htmlunit.sourceforge.net/&quot; target=&quot;_blank&quot;>http://htmlunit.sourceforge.net/&lt;/a>&lt;br />&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    &lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
